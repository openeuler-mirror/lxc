From e1e3ad7bc7cb1a26cca676ff5e4a5ceaf7eedaee Mon Sep 17 00:00:00 2001
From: tanyifeng <tanyifeng1@huawei.com>
Date: Wed, 15 May 2019 12:42:08 +0800
Subject: [PATCH 49/49] make /dev bind mount from host tmpfs for system
 container

Signed-off-by: zhangsong <zhangsong34@huawei.com>
---
 src/lxc/conf.c | 33 +++++++++++++++++++++++++++++++--
 1 file changed, 31 insertions(+), 2 deletions(-)

diff --git a/src/lxc/conf.c b/src/lxc/conf.c
index 15d8e42..4d8fa2a 100644
--- a/src/lxc/conf.c
+++ b/src/lxc/conf.c
@@ -1074,8 +1074,13 @@ on_error:
 /* Just create a path for /dev under $lxcpath/$name and in rootfs If we hit an
  * error, log it but don't fail yet.
  */
+#ifdef HAVE_ISULAD
+static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs,
+			 int autodevtmpfssize, const char *lxcpath, char *systemd)
+#else
 static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs,
 			 int autodevtmpfssize, const char *lxcpath)
+#endif
 {
 	__do_free char *path = NULL;
 	int ret;
@@ -1088,6 +1093,7 @@ static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs,
 	/* $(rootfs->mount) + "/dev/pts" + '\0' */
 	clen = (rootfs->path ? strlen(rootfs->mount) : 0) + 9;
 	path = must_realloc(NULL, clen);
+
 	sprintf(mount_options, "size=%d,mode=755", (autodevtmpfssize != 0) ? autodevtmpfssize : 500000);
 	DEBUG("Using mount options: %s", mount_options);
 
@@ -1103,6 +1109,23 @@ static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs,
 		goto reset_umask;
 	}
 
+#ifdef HAVE_ISULAD
+        if (systemd != NULL && !strcmp(systemd, "true")) {
+                ret = mount(path, path, "", MS_BIND, NULL);
+                if (ret < 0) {
+		        SYSERROR("Failed to bind mount path \"%s\"", path);
+		        goto reset_umask;
+                }
+        } else {
+	        ret = safe_mount("none", path, "tmpfs", 0, mount_options,
+			 rootfs->path ? rootfs->mount : NULL);
+	        if (ret < 0) {
+		        SYSERROR("Failed to mount tmpfs on \"%s\"", path);
+		        goto reset_umask;
+	        }
+	        TRACE("Mounted tmpfs on \"%s\"", path);
+        }
+#else
 	ret = safe_mount("none", path, "tmpfs", 0, mount_options,
 			 rootfs->path ? rootfs->mount : NULL );
 	if (ret < 0) {
@@ -1110,6 +1133,7 @@ static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs,
 		goto reset_umask;
 	}
 	TRACE("Mounted tmpfs on \"%s\"", path);
+#endif
 
 	ret = snprintf(path, clen, "%s/dev/pts", rootfs->path ? rootfs->mount : "");
 	if (ret < 0 || (size_t)ret >= clen) {
@@ -4674,7 +4698,11 @@ int lxc_setup(struct lxc_handler *handler)
 	}
 
 	if (lxc_conf->autodev > 0) {
+#ifdef HAVE_ISULAD
+		ret = mount_autodev(name, &lxc_conf->rootfs, lxc_conf->autodevtmpfssize, lxcpath, lxc_conf->systemd);
+#else
 		ret = mount_autodev(name, &lxc_conf->rootfs, lxc_conf->autodevtmpfssize, lxcpath);
+#endif
 		if (ret < 0)
 			return log_error(-1, "Failed to mount \"/dev\"");
 	}
@@ -4838,11 +4866,12 @@ int lxc_setup(struct lxc_handler *handler)
 	//isulad: system container, remount /proc/sys/xxx by mount_list
 	if (lxc_conf->systemd != NULL && strcmp(lxc_conf->systemd, "true") == 0) {
 		if (!lxc_list_empty(&lxc_conf->mount_list)) {
-			if (remount_proc_sys_mount_entries(&lxc_conf->mount_list, lxc_conf->lsm_aa_allow_nesting)) {
+			if (remount_proc_sys_mount_entries(&lxc_conf->mount_list,
+							   lxc_conf->lsm_aa_allow_nesting)) {
 				return log_error(-1, "failed to remount /proc/sys");
 			}
 		}
-	}
+        }
 
 	// isulad: create link /etc/mtab for /proc/mounts
 	if (create_mtab_link() != 0) {
-- 
1.8.3.1

