From 8b3ba34aad74f1bf204095a479c9d28436de2627 Mon Sep 17 00:00:00 2001
From: LiFeng <lifeng68@huawei.com>
Date: Wed, 18 Dec 2019 09:01:25 -0500
Subject: [PATCH 133/140] lxc: fix bug in cgfsng

Signed-off-by: LiFeng <lifeng68@huawei.com>
---
 src/lxc/cgroups/cgfsng.c | 100 +++++++++++++++++++++++------------------------
 1 file changed, 50 insertions(+), 50 deletions(-)

diff --git a/src/lxc/cgroups/cgfsng.c b/src/lxc/cgroups/cgfsng.c
index 2f86a66..5908c31 100644
--- a/src/lxc/cgroups/cgfsng.c
+++ b/src/lxc/cgroups/cgfsng.c
@@ -387,14 +387,8 @@ static bool cg_legacy_filter_and_set_cpus(char *path, bool am_initialized)
 	char *cpulist = NULL, *isolcpus = NULL, *posscpus = NULL;
 	uint32_t *isolmask = NULL, *possmask = NULL;
 	bool bret = false, flipped_bit = false;
+	bool need_read_parent = false;
 
-	lastslash = strrchr(path, '/');
-	if (!lastslash) {
-		ERROR("Failed to detect \"/\" in \"%s\"", path);
-		return bret;
-	}
-	oldv = *lastslash;
-	*lastslash = '\0';
 	fpath = must_make_path(path, "cpuset.cpus", NULL);
 	posscpus = read_file(fpath);
 	if (!posscpus) {
@@ -402,6 +396,25 @@ static bool cg_legacy_filter_and_set_cpus(char *path, bool am_initialized)
 		goto on_error;
 	}
 
+	if (strcmp(posscpus, "\n") == 0) {
+		need_read_parent = true;
+		free(fpath);
+		free(posscpus);
+		lastslash = strrchr(path, '/');
+		if (!lastslash) {
+			ERROR("Failed to detect \"/\" in \"%s\"", path);
+			return bret;
+		}
+		oldv = *lastslash;
+		*lastslash = '\0';
+		fpath = must_make_path(path, "cpuset.cpus", NULL);
+		posscpus = read_file(fpath);
+		if (!posscpus) {
+			SYSERROR("Failed to read file \"%s\"", fpath);
+			goto on_error;
+		}
+	}
+
 	/* Get maximum number of cpus found in possible cpuset. */
 	maxposs = get_max_cpus(posscpus);
 	if (maxposs < 0 || maxposs >= INT_MAX - 1)
@@ -489,7 +502,9 @@ static bool cg_legacy_filter_and_set_cpus(char *path, bool am_initialized)
 	}
 
 copy_parent:
-	*lastslash = oldv;
+	if (need_read_parent) {
+		*lastslash = oldv;
+	}
 	free(fpath);
 	fpath = must_make_path(path, "cpuset.cpus", NULL);
 	ret = lxc_write_to_file(fpath, cpulist, strlen(cpulist), false, 0666);
@@ -522,6 +537,25 @@ static bool copy_parent_file(char *path, char *file)
 	char *fpath, *lastslash, oldv;
 	int len = 0;
 	char *value = NULL;
+	char *current = NULL;
+
+	fpath = must_make_path(path, file, NULL);
+	current = read_file(fpath);
+
+	if (current == NULL) {
+		SYSERROR("Failed to read file \"%s\"", fpath);
+		free(fpath);
+		return false;
+	}
+
+	if (strcmp(current, "\n") != 0) {
+		free(fpath);
+		free(current);
+		return true;
+	}
+
+	free(fpath);
+	free(current);
 
 	lastslash = strrchr(path, '/');
 	if (!lastslash) {
@@ -560,8 +594,6 @@ on_error:
 static bool build_sub_cpuset_cgroup_dir(char *cgpath)
 {
 	int ret;
-	char v;
-	char *clonechildrenpath = NULL;
 
 	ret = mkdir_p(cgpath, 0755);
 	if (ret < 0) {
@@ -571,51 +603,19 @@ static bool build_sub_cpuset_cgroup_dir(char *cgpath)
 		}
 	}
 
-	clonechildrenpath = must_make_path(cgpath, "cgroup.clone_children", NULL);
-	/* unified hierarchy doesn't have clone_children */
-	if (!file_exists(clonechildrenpath)) {
-		free(clonechildrenpath);
-		return true;
-	}
-
-	ret = lxc_read_from_file(clonechildrenpath, &v, 1);
-	if (ret < 0) {
-		SYSERROR("Failed to read file \"%s\"", clonechildrenpath);
-		free(clonechildrenpath);
-		return false;
-	}
-
 	/* Make sure any isolated cpus are removed from cpuset.cpus. */
-	if (!cg_legacy_filter_and_set_cpus(cgpath, v == '1')) {
+	if (!cg_legacy_filter_and_set_cpus(cgpath, false)) {
 		SYSERROR("Failed to remove isolated cpus");
-		free(clonechildrenpath);
 		return false;
 	}
 
-	/* Already set for us by someone else. */
-	if (v == '1') {
-		DEBUG("\"cgroup.clone_children\" was already set to \"1\"");
-		free(clonechildrenpath);
-		return true;
-	}
-
 	/* copy parent's settings */
 	if (!copy_parent_file(cgpath, "cpuset.mems")) {
 		SYSERROR("Failed to copy \"cpuset.mems\" settings");
-		free(clonechildrenpath);
 		return false;
 	}
 
-	ret = lxc_write_to_file(clonechildrenpath, "1", 1, false, 0666);
-	if (ret < 0) {
-		/* Set clone_children so children inherit our settings */
-		SYSERROR("Failed to write 1 to \"%s\"", clonechildrenpath);
-		free(clonechildrenpath);
-		return false;
-	}
-	free(clonechildrenpath);
 	return true;
-
 }
 
 /* Initialize the cpuset hierarchy in first directory of @gname and set
@@ -647,13 +647,13 @@ static bool cg_legacy_handle_cpuset_hierarchy(struct hierarchy *h, char *cgname)
 			}
 			slash = strchr(slash + 1, '/');
 		}
-	} else {
-		cgpath = must_make_path(h->mountpoint, h->container_base_path, cgname, NULL);
-		sub_mk_success = build_sub_cpuset_cgroup_dir(cgpath);
-		free(cgpath);
-		if (!sub_mk_success) {
-			return false;
-		}
+	}
+
+	cgpath = must_make_path(h->mountpoint, h->container_base_path, cgname, NULL);
+	sub_mk_success = build_sub_cpuset_cgroup_dir(cgpath);
+	free(cgpath);
+	if (!sub_mk_success) {
+		return false;
 	}
 
 	return true;
-- 
1.8.3.1

