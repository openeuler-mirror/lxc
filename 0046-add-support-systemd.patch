From 1922cc534f04a7a006064e7eae2dea44d0000cc3 Mon Sep 17 00:00:00 2001
From: tanyifeng <tanyifeng1@huawei.com>
Date: Sat, 20 Apr 2019 22:40:18 +0800
Subject: [PATCH 46/49] add support systemd

Signed-off-by: zhangsong <zhangsong34@huawei.com>
---
 src/lxc/cgroups/cgfsng.c | 15 +++++++++++++++
 src/lxc/conf.c           |  1 +
 src/lxc/confile.c        | 30 ++++++++++++++++++++++++++++++
 3 files changed, 46 insertions(+)

diff --git a/src/lxc/cgroups/cgfsng.c b/src/lxc/cgroups/cgfsng.c
index 002f051..4abaa86 100644
--- a/src/lxc/cgroups/cgfsng.c
+++ b/src/lxc/cgroups/cgfsng.c
@@ -2096,6 +2096,7 @@ __cgfsng_ops static bool cgfsng_mount(struct cgroup_ops *ops,
 {
 	int i, ret;
 	char *tmpfspath = NULL;
+	char *systemdpath = NULL;
 	bool has_cgns = false, retval = false, wants_force_mount = false;
 	char **merged = NULL;
 
@@ -2242,10 +2243,24 @@ __cgfsng_ops static bool cgfsng_mount(struct cgroup_ops *ops,
 		}
 	}
 
+        // isulad: remount /sys/fs/cgroup/systemd to readwrite for system container
+        if (handler->conf->systemd != NULL && strcmp(handler->conf->systemd, "true") == 0) {
+                systemdpath = must_make_path(root, "/sys/fs/cgroup/systemd", NULL);
+                ret = mount(systemdpath, systemdpath, "bind",
+                            MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME|MS_BIND|MS_REMOUNT, NULL);
+                if (ret < 0) {
+                        SYSERROR("Failed to remount /sys/fs/cgroup/systemd.");
+                        goto on_error;
+                }
+        }
+
 	retval = true;
 
 on_error:
 	free(tmpfspath);
+        if (systemdpath != NULL) {
+                free(systemdpath);
+        }
 	lxc_free_array((void **)merged, free);
 	return retval;
 }
diff --git a/src/lxc/conf.c b/src/lxc/conf.c
index d7a78bd..235965f 100644
--- a/src/lxc/conf.c
+++ b/src/lxc/conf.c
@@ -5283,6 +5283,7 @@ void lxc_conf_free(struct lxc_conf *conf)
 	if (conf->exit_fd != -1) {
 		close(conf->exit_fd);
 	}
+	free(conf->systemd);
 	lxc_clear_init_args(conf);
 	lxc_clear_init_groups(conf);
 	lxc_clear_populate_devices(conf);
diff --git a/src/lxc/confile.c b/src/lxc/confile.c
index 8790494..771f635 100644
--- a/src/lxc/confile.c
+++ b/src/lxc/confile.c
@@ -154,6 +154,7 @@ lxc_config_define(populate_device);
 lxc_config_define(umask);
 lxc_config_define(rootfs_masked_paths);
 lxc_config_define(rootfs_ro_paths);
+lxc_config_define(systemd);
 #endif
 
 /*
@@ -274,6 +275,7 @@ static struct lxc_config_t config_jump_table[] = {
 	{ "lxc.isulad.umask",              set_config_umask,                       get_config_umask,                       clr_config_umask,                     },
 	{ "lxc.isulad.rootfs.maskedpaths", set_config_rootfs_masked_paths,         get_config_rootfs_masked_paths,         clr_config_rootfs_masked_paths,       },
 	{ "lxc.isulad.rootfs.ropaths",     set_config_rootfs_ro_paths,             get_config_rootfs_ro_paths,             clr_config_rootfs_ro_paths,           },
+	{ "lxc.isulad.systemd",            set_config_systemd,                     get_config_systemd,                     clr_config_systemd,                   },
 #endif
 };
 
@@ -6587,4 +6589,32 @@ static inline int clr_config_rootfs_ro_paths(const char *key, struct lxc_conf *c
 	return lxc_clear_rootfs_ro_paths(c);
 }
 
+/* isulad: set config for systemd */
+static int set_config_systemd(const char *key, const char *value,
+			      struct lxc_conf *lxc_conf, void *data)
+{
+	if (lxc_config_value_empty(value)) {
+		ERROR("Empty umask");
+		return -1;
+	}
+	lxc_conf->systemd = strdup(value);
+	return 0;
+}
+
+/* isulad add: get systemd value*/
+static int get_config_systemd(const char *key, char *retv, int inlen,
+			      struct lxc_conf *c, void *data)
+{
+	return lxc_get_conf_str(retv, inlen, c->systemd);
+}
+
+/* isulad add: clear systemd value */
+static inline int clr_config_systemd(const char *key, struct lxc_conf *c,
+				     void *data)
+{
+	free(c->systemd);
+	c->systemd = NULL;
+	return 0;
+}
+
 #endif
-- 
1.8.3.1

