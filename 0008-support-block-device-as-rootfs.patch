From 6792a7f76d9084734d94e815b462ed2977fe107e Mon Sep 17 00:00:00 2001
From: tanyifeng <tanyifeng1@huawei.com>
Date: Tue, 15 Jan 2019 16:00:30 +0800
Subject: [PATCH 08/49] support block device as rootfs

Signed-off-by: LiFeng <lifeng68@huawei.com>
Signed-off-by: WangFengTu <wangfengtu@huawei.com>
---
 src/lxc/Makefile.am             |  1 +
 src/lxc/conf.c                  | 36 +++++++++++++++++
 src/lxc/storage/block.c         | 86 +++++++++++++++++++++++++++++++++++++++++
 src/lxc/storage/block.h         | 41 ++++++++++++++++++++
 src/lxc/storage/dir.c           | 14 ++++++-
 src/lxc/storage/storage.c       | 21 ++++++++++
 src/lxc/storage/storage_utils.c |  4 ++
 7 files changed, 202 insertions(+), 1 deletion(-)
 create mode 100644 src/lxc/storage/block.c
 create mode 100644 src/lxc/storage/block.h

diff --git a/src/lxc/Makefile.am b/src/lxc/Makefile.am
index 21441c0..d8c2492 100644
--- a/src/lxc/Makefile.am
+++ b/src/lxc/Makefile.am
@@ -139,6 +139,7 @@ liblxc_la_SOURCES = af_unix.c af_unix.h \
 		    start.c start.h \
 		    storage/btrfs.c storage/btrfs.h \
 		    storage/dir.c storage/dir.h \
+		    storage/block.c storage/block.h \
 		    storage/loop.c storage/loop.h \
 		    storage/lvm.c storage/lvm.h \
 		    storage/nbd.c storage/nbd.h \
diff --git a/src/lxc/conf.c b/src/lxc/conf.c
index 43437af..35488e0 100644
--- a/src/lxc/conf.c
+++ b/src/lxc/conf.c
@@ -3383,6 +3383,36 @@ reset_umask:
 	INFO("Populated devices into container /dev");
 	return ret;
 }
+
+// isulad: setup rootfs mountopts
+static int setup_rootfs_mountopts(const struct lxc_rootfs *rootfs)
+{
+	unsigned long mflags, mntflags, pflags;
+	char *mntdata;
+
+	if(!rootfs || !rootfs->options)
+		return 0;
+
+	if (parse_propagationopts(rootfs->options, &pflags) < 0) {
+		return -1;
+	}
+
+	if (parse_mntopts(rootfs->options, &mntflags, &mntdata) < 0) {
+		free(mntdata);
+		return -1;
+	}
+	free(mntdata);
+
+	if (mntflags & MS_RDONLY) {
+		mflags = add_required_remount_flags("/", NULL, MS_BIND | MS_REC | mntflags | pflags | MS_REMOUNT);
+		DEBUG("remounting /");
+		if (mount("/", "/", NULL, mflags, 0) < 0) {
+			SYSERROR("Failed to remount /");
+			return -1;
+		}
+	}
+	return 0;
+}
 #endif
 
 int lxc_setup(struct lxc_handler *handler)
@@ -3531,6 +3561,12 @@ int lxc_setup(struct lxc_handler *handler)
 	if (ret < 0)
 		return log_error(-1, "Failed to setup new devpts instance");
 
+#ifdef HAVE_ISULAD
+        if (setup_rootfs_mountopts(&lxc_conf->rootfs)) {
+               return log_error(-1, "failed to set rootfs for '%s'", name);
+        }
+#endif
+
 	ret = lxc_create_ttys(handler);
 	if (ret < 0)
 		return -1;
diff --git a/src/lxc/storage/block.c b/src/lxc/storage/block.c
new file mode 100644
index 0000000..eb75e70
--- /dev/null
+++ b/src/lxc/storage/block.c
@@ -0,0 +1,86 @@
+/*
+ * lxc: linux Container library
+ *
+ * (C) Copyright IBM Corp. 2007, 2008
+ *
+ * Authors:
+ * Daniel Lezcano <daniel.lezcano at free.fr>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE 1
+#endif
+#include <stdint.h>
+#include <string.h>
+
+#include "config.h"
+#include "log.h"
+#include "storage.h"
+#include "storage_utils.h"
+#include "utils.h"
+
+lxc_log_define(blk, lxc);
+
+int blk_destroy(struct lxc_storage *orig)
+{
+	return 0;
+}
+
+bool blk_detect(const char *path)
+{
+	struct stat statbuf;
+	int ret;
+
+	if (!strncmp(path, "blk:", 4))
+		return true;
+
+	ret = stat(path, &statbuf);
+	if (ret == -1 && errno == EPERM) {
+		SYSERROR("blk_detect: failed to look at \"%s\"", path);
+		return false;
+	}
+
+	if (ret == 0 && S_ISBLK(statbuf.st_mode))
+		return true;
+
+	return false;
+}
+
+int blk_mount(struct lxc_storage *bdev)
+{
+	const char *src;
+	if (strcmp(bdev->type, "blk"))
+		return -22;
+
+	if (!bdev->src || !bdev->dest)
+		return -22;
+
+	src = lxc_storage_get_path(bdev->src, bdev->type);
+
+	return mount_unknown_fs(src, bdev->dest, bdev->mntopts);
+}
+
+int blk_umount(struct lxc_storage *bdev)
+{
+	if (strcmp(bdev->type, "blk"))
+		return -22;
+
+	if (!bdev->src || !bdev->dest)
+		return -22;
+
+	return umount(bdev->dest);
+}
diff --git a/src/lxc/storage/block.h b/src/lxc/storage/block.h
new file mode 100644
index 0000000..2fa7565
--- /dev/null
+++ b/src/lxc/storage/block.h
@@ -0,0 +1,41 @@
+/*
+ * lxc: linux Container library
+ *
+ * (C) Copyright IBM Corp. 2007, 2008
+ *
+ * Authors:
+ * Daniel Lezcano <daniel.lezcano at free.fr>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef __LXC_BLK_H
+#define __LXC_BLK_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+struct lxc_storage;
+
+struct bdev_specs;
+
+struct lxc_conf;
+
+extern int blk_destroy(struct lxc_storage *orig);
+extern bool blk_detect(const char *path);
+extern int blk_mount(struct lxc_storage *bdev);
+extern int blk_umount(struct lxc_storage *bdev);
+
+#endif /* __LXC_BLK_H */
diff --git a/src/lxc/storage/dir.c b/src/lxc/storage/dir.c
index 18a10a4..b3dbbd0 100644
--- a/src/lxc/storage/dir.c
+++ b/src/lxc/storage/dir.c
@@ -127,7 +127,11 @@ bool dir_detect(const char *path)
 int dir_mount(struct lxc_storage *bdev)
 {
 	__do_free char *mntdata = NULL;
+#ifdef HAVE_ISULAD
+	unsigned long mntflags = 0, pflags = 0;
+#else
 	unsigned long mflags = 0, mntflags = 0, pflags = 0;
+#endif
 	int ret;
 	const char *src;
 
@@ -147,6 +151,13 @@ int dir_mount(struct lxc_storage *bdev)
 
 	src = lxc_storage_get_path(bdev->src, bdev->type);
 
+#ifdef HAVE_ISULAD
+	ret = mount(src, bdev->dest, "bind", MS_BIND | MS_REC | (mntflags & ~MS_RDONLY) | pflags, mntdata);
+	if (ret < 0) {
+		return log_error_errno(-errno, errno, "Failed to mount \"%s\" on \"%s\"", src, bdev->dest);
+	}
+	TRACE("Mounted \"%s\" on \"%s\"", src, bdev->dest);
+#else
 	ret = mount(src, bdev->dest, "bind", MS_BIND | MS_REC | mntflags | pflags, mntdata);
 	if (ret < 0)
 		return log_error_errno(-errno, errno, "Failed to mount \"%s\" on \"%s\"", src, bdev->dest);
@@ -161,9 +172,10 @@ int dir_mount(struct lxc_storage *bdev)
 			DEBUG("Remounted \"%s\" on \"%s\" read-only with options \"%s\", mount flags \"%lu\", and propagation flags \"%lu\"",
 			      src ? src : "(none)", bdev->dest ? bdev->dest : "(none)", mntdata, mflags, pflags);
 	}
-
 	TRACE("Mounted \"%s\" on \"%s\" with options \"%s\", mount flags \"%lu\", and propagation flags \"%lu\"",
 	      src ? src : "(none)", bdev->dest ? bdev->dest : "(none)", mntdata, mflags, pflags);
+#endif
+
 	return 0;
 }
 
diff --git a/src/lxc/storage/storage.c b/src/lxc/storage/storage.c
index 3f1b713..876311a 100644
--- a/src/lxc/storage/storage.c
+++ b/src/lxc/storage/storage.c
@@ -41,6 +41,7 @@
 #include "storage_utils.h"
 #include "utils.h"
 #include "zfs.h"
+#include "block.h"
 
 #ifndef HAVE_STRLCPY
 #include "include/strlcpy.h"
@@ -94,6 +95,22 @@ static const struct lxc_storage_ops loop_ops = {
     .can_backup = true,
 };
 
+#ifdef HAVE_ISULAD
+/* block */
+static const struct lxc_storage_ops blk_ops = {
+    .detect = &blk_detect,
+    .mount = &blk_mount,
+    .umount = &blk_umount,
+    .clone_paths = NULL,
+    .destroy = &blk_destroy,
+    .create = NULL,
+    .copy = NULL,
+    .snapshot = NULL,
+    .can_snapshot = false,
+    .can_backup = true,
+};
+#endif
+
 /* lvm */
 static const struct lxc_storage_ops lvm_ops = {
     .detect = &lvm_detect,
@@ -179,6 +196,10 @@ static const struct lxc_storage_type bdevs[] = {
 	{ .name = "overlayfs", .ops = &ovl_ops,   },
 	{ .name = "loop",      .ops = &loop_ops,  },
 	{ .name = "nbd",       .ops = &nbd_ops,   },
+#ifdef HAVE_ISULAD
+	//isulad: block device
+	{ .name = "blk",       .ops = &blk_ops,   }
+#endif
 };
 
 static const size_t numbdevs = sizeof(bdevs) / sizeof(struct lxc_storage_type);
diff --git a/src/lxc/storage/storage_utils.c b/src/lxc/storage/storage_utils.c
index a3ee353..bfbb782 100644
--- a/src/lxc/storage/storage_utils.c
+++ b/src/lxc/storage/storage_utils.c
@@ -335,7 +335,11 @@ int find_fstype_cb(char *buffer, void *data)
 		return 0;
 	}
 
+#ifdef HAVE_ISULAD
+	if (mount(cbarg->rootfs, cbarg->target, fstype, (mntflags & ~MS_RDONLY), mntdata)) {
+#else
 	if (mount(cbarg->rootfs, cbarg->target, fstype, mntflags, mntdata)) {
+#endif
 		SYSDEBUG("Failed to mount");
 		free(mntdata);
 		return 0;
-- 
1.8.3.1

