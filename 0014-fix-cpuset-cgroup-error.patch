From 63945e7f907d7c2943505fffeca606a1c96121fb Mon Sep 17 00:00:00 2001
From: jikai <jikai11@huawei.com>
Date: Wed, 7 Feb 2024 17:36:44 +0800
Subject: [PATCH] fix cpuset cgroup error

Signed-off-by: jikai <jikai11@huawei.com>
---
 src/lxc/cgroups/cgfsng.c | 22 ++++++++++------------
 1 file changed, 10 insertions(+), 12 deletions(-)

diff --git a/src/lxc/cgroups/cgfsng.c b/src/lxc/cgroups/cgfsng.c
index 984e969..471c281 100644
--- a/src/lxc/cgroups/cgfsng.c
+++ b/src/lxc/cgroups/cgfsng.c
@@ -1007,18 +1007,6 @@ static bool cgroup_tree_create(struct cgroup_ops *ops, struct lxc_conf *conf,
 	 */
 	cpuset_v1 = !is_unified_hierarchy(h) && string_in_list(h->controllers, "cpuset");
 
-#ifdef HAVE_ISULAD
-	/* ensure that cpuset cgroup was set in the whole cgroup path, though lxc does
-	 * cpuset1_initialize(set cgroup.clone_children to 1 and cpuset.cpus and cpuset.mems)
-	 * but it only does so for the first layer of the cgroup path.
-	 * Since K8S could create the path already, so we need to ensure the cpuset cgroup was set
-	 */
-	if (cpuset_v1 && !isulad_cg_legacy_handle_cpuset_hierarchy(h, ops->container_cgroup)) {
-		ERROR("Failed to handle legacy cpuset controller");
-		return false;
-	}
-#endif
-
 	if (payload && cgroup_leaf) {
 		/* With isolation both parts need to not already exist. */
 		fd_limit = __cgroup_tree_create(h->dfd_base, cgroup_limit_dir, 0755, cpuset_v1, false);
@@ -1886,6 +1874,11 @@ __cgfsng_ops static bool cgfsng_payload_enter(struct cgroup_ops *ops,
 
 #ifdef HAVE_ISULAD
 retry:
+		/* ensure that cpuset cgroup was set in the whole cgroup path, though lxc does
+		 * cpuset1_initialize(set cgroup.clone_children to 1 and cpuset.cpus and cpuset.mems)
+		 * but it only does so for the first layer of the cgroup path.
+		 * Since K8S could create the path already, so we need to ensure the cpuset cgroup was set
+		 */
 		ret = lxc_writeat(h->dfd_con, "cgroup.procs", pidstr, len);
 		if (ret != 0) {
 			if (retry_count < max_retry) {
@@ -3509,6 +3502,11 @@ static int cg_legacy_set_data(struct cgroup_ops *ops, const char *filename,
 #ifdef HAVE_ISULAD
 	fullpath = must_make_path(h->path_con, filename, NULL);
 retry:
+	/* ensure that cpuset cgroup was set in the whole cgroup path, though lxc does
+	 * cpuset1_initialize(set cgroup.clone_children to 1 and cpuset.cpus and cpuset.mems)
+	 * but it only does so for the first layer of the cgroup path.
+	 * Since K8S could create the path already, so we need to ensure the cpuset cgroup was set
+	 */
 	nret = lxc_write_to_file(fullpath, value, strlen(value), false, 0666);
 	if (nret != 0) {
 		if (retry_count < max_retry) {
-- 
2.33.0

