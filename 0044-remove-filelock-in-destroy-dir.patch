From 0441dc446ad9f0bc02c5ca7a76d793c8a7734fd9 Mon Sep 17 00:00:00 2001
From: haozi007 <liuhao27@huawei.com>
Date: Thu, 16 Apr 2020 15:39:50 +0800
Subject: [PATCH 44/49] remove filelock in destroy dir

Signed-off-by: haozi007 <liuhao27@huawei.com>
---
 src/lxc/lxccontainer.c | 21 +++++++++++++++++++++
 src/lxc/lxclock.c      | 27 +++++++++++++++++++++++++++
 src/lxc/lxclock.h      |  4 ++++
 src/lxc/start.c        |  7 +++++++
 src/lxc/storage/dir.c  |  4 ++++
 5 files changed, 63 insertions(+)

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index ed09a59..6281a8a 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3168,8 +3168,19 @@ static bool container_destroy(struct lxc_container *c,
 	bool bret = false;
 	int ret = 0;
 
+#ifdef HAVE_ISULAD
+	if (!c)
+		return false;
+	// isulad: if container is not defined, we need to remove disk lock file
+	// which is created in lxc_container_new.
+	if (!do_lxcapi_is_defined(c)) {
+		container_disk_removelock(c);
+		return false;
+	}
+#else
 	if (!c || !do_lxcapi_is_defined(c))
 		return false;
+#endif
 
 	conf = c->lxc_conf;
 	if (container_disk_lock(c))
@@ -3310,13 +3321,23 @@ out:
 		free(path);
 
 	container_disk_unlock(c);
+#ifdef HAVE_ISULAD
+	if (bret && container_disk_removelock(c)) {
+		bret = false;
+	}
+#endif
 	return bret;
 }
 
 static bool do_lxcapi_destroy(struct lxc_container *c)
 {
+#ifdef HAVE_ISULAD
+	if (!c)
+		return false;
+#else
 	if (!c || !lxcapi_is_defined(c))
 		return false;
+#endif
 
 	if (c->lxc_conf && c->lxc_conf->rootfs.managed) {
 		if (has_snapshots(c)) {
diff --git a/src/lxc/lxclock.c b/src/lxc/lxclock.c
index 318e5bf..bb0dca0 100644
--- a/src/lxc/lxclock.c
+++ b/src/lxc/lxclock.c
@@ -370,3 +370,30 @@ void container_disk_unlock(struct lxc_container *c)
 	lxcunlock(c->slock);
 	lxcunlock(c->privlock);
 }
+
+#ifdef HAVE_ISULAD
+static int lxc_removelock(struct lxc_lock *l)
+{
+	int ret = 0;
+
+	if (l->type == LXC_LOCK_FLOCK) {
+		ret = unlink(l->u.f.fname);
+		if (ret && errno != ENOENT) {
+			SYSERROR("Error unlink %s", l->u.f.fname);
+			return ret;
+		}
+	}
+
+	return ret;
+}
+
+int container_disk_removelock(struct lxc_container *c)
+{
+	int ret;
+
+	ret = lxc_removelock(c->slock);
+	if (ret)
+		return ret;
+	return lxc_removelock(c->privlock);
+}
+#endif
diff --git a/src/lxc/lxclock.h b/src/lxc/lxclock.h
index 9f9bc3b..6a71d7c 100644
--- a/src/lxc/lxclock.h
+++ b/src/lxc/lxclock.h
@@ -154,4 +154,8 @@ extern int container_disk_lock(struct lxc_container *c);
  */
 extern void container_disk_unlock(struct lxc_container *c);
 
+#ifdef HAVE_ISULAD
+int container_disk_removelock(struct lxc_container *c);
+#endif
+
 #endif
diff --git a/src/lxc/start.c b/src/lxc/start.c
index 134235f..6779cee 100644
--- a/src/lxc/start.c
+++ b/src/lxc/start.c
@@ -2143,6 +2143,13 @@ static int lxc_spawn(struct lxc_handler *handler)
 	if (ret < 0)
 		SYSERROR("Failed to set environment variable: LXC_PID=%s", pidstr);
 
+#ifdef HAVE_ISULAD
+	if (handler->cgroup_ops->container_cgroup) {
+		if (setenv("LXC_CGROUP_PATH", handler->cgroup_ops->container_cgroup, 1))
+			SYSERROR("Failed to set environment variable: LXC_CGROUP_PATH=%s.", handler->cgroup_ops->container_cgroup);
+	}
+#endif
+
 	for (i = 0; i < LXC_NS_MAX; i++)
 		if (handler->ns_on_clone_flags & ns_info[i].clone_flag)
 			INFO("Cloned %s", ns_info[i].flag_name);
diff --git a/src/lxc/storage/dir.c b/src/lxc/storage/dir.c
index 1dc95f1..485572a 100644
--- a/src/lxc/storage/dir.c
+++ b/src/lxc/storage/dir.c
@@ -94,6 +94,9 @@ int dir_create(struct lxc_storage *bdev, const char *dest, const char *n,
 
 int dir_destroy(struct lxc_storage *orig)
 {
+#ifdef HAVE_ISULAD
+	// isulad: do not destroy rootfs for directory, it should be managed by caller
+#else
 	int ret;
 	const char *src;
 
@@ -102,6 +105,7 @@ int dir_destroy(struct lxc_storage *orig)
 	ret = lxc_rmdir_onedev(src, NULL);
 	if (ret < 0)
 		return log_error_errno(ret, errno, "Failed to delete \"%s\"", src);
+#endif
 
 	return 0;
 }
-- 
1.8.3.1

