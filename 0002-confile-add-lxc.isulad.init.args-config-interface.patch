From 549a0a959b84a483d9f733cf7a157900f4c889c4 Mon Sep 17 00:00:00 2001
From: LiFeng <lifeng68@huawei.com>
Date: Sat, 11 Apr 2020 16:16:15 +0800
Subject: [PATCH 02/49] confile: add lxc.isulad.init.args config interface

lxc.isulad.init.args config interface is used to specify the args for
the container.

Signed-off-by: LiFeng <lifeng68@huawei.com>
---
 src/lxc/conf.c         | 17 ++++++++++++++
 src/lxc/conf.h         | 11 ++++++++-
 src/lxc/confile.c      | 62 ++++++++++++++++++++++++++++++++++++++++++++++++++
 src/lxc/lxccontainer.c | 33 +++++++++++++++++++++++++++
 4 files changed, 122 insertions(+), 1 deletion(-)

diff --git a/src/lxc/conf.c b/src/lxc/conf.c
index 2f6be9f..62a6979 100644
--- a/src/lxc/conf.c
+++ b/src/lxc/conf.c
@@ -3835,6 +3835,9 @@ void lxc_conf_free(struct lxc_conf *conf)
 	free(conf->cgroup_meta.controllers);
 	free(conf->shmount.path_host);
 	free(conf->shmount.path_cont);
+#ifdef HAVE_ISULAD
+	lxc_clear_init_args(conf);
+#endif
 	free(conf);
 }
 
@@ -4645,3 +4648,17 @@ struct lxc_list *sort_cgroup_settings(struct lxc_list *cgroup_settings)
 
 	return result;
 }
+
+#ifdef HAVE_ISULAD
+/*isulad clear init args*/
+int lxc_clear_init_args(struct lxc_conf *lxc_conf)
+{
+	size_t i;
+
+	for (i = 0; i < lxc_conf->init_argc; i++)
+		free(lxc_conf->init_argv[i]);
+	free(lxc_conf->init_argv);
+
+	return 0;
+}
+#endif
diff --git a/src/lxc/conf.h b/src/lxc/conf.h
index 64885c3..8a198e4 100644
--- a/src/lxc/conf.h
+++ b/src/lxc/conf.h
@@ -398,6 +398,13 @@ struct lxc_conf {
 		/* Absolute path (in the container) to the shared mount point */
 		char *path_cont;
 	} shmount;
+
+#ifdef HAVE_ISULAD
+	/* isulad add: init args used to repalce init_cmd*/
+	char **init_argv;
+	size_t init_argc;
+#endif
+
 };
 
 extern int write_id_mapping(enum idtype idtype, pid_t pid, const char *buf,
@@ -470,5 +477,7 @@ extern int lxc_clear_namespace(struct lxc_conf *c);
 extern int userns_exec_minimal(const struct lxc_conf *conf,
 			       int (*fn_parent)(void *), void *fn_parent_data,
 			       int (*fn_child)(void *), void *fn_child_data);
-
+#ifdef HAVE_ISULAD
+int lxc_clear_init_args(struct lxc_conf *lxc_conf);
+#endif
 #endif /* __LXC_CONF_H */
diff --git a/src/lxc/confile.c b/src/lxc/confile.c
index 0ca577f..e535beb 100644
--- a/src/lxc/confile.c
+++ b/src/lxc/confile.c
@@ -147,6 +147,9 @@ lxc_config_define(tty_dir);
 lxc_config_define(uts_name);
 lxc_config_define(sysctl);
 lxc_config_define(proc);
+#ifdef HAVE_ISULAD
+lxc_config_define(init_args);
+#endif
 
 /*
  * Important Note:
@@ -259,6 +262,10 @@ static struct lxc_config_t config_jump_table[] = {
 	{ "lxc.uts.name",                  set_config_uts_name,                    get_config_uts_name,                    clr_config_uts_name,                  },
 	{ "lxc.sysctl",                    set_config_sysctl,                      get_config_sysctl,                      clr_config_sysctl,                    },
 	{ "lxc.proc",                      set_config_proc,                        get_config_proc,                        clr_config_proc,                      },
+#ifdef HAVE_ISULAD
+	{ "lxc.isulad.init.args",          set_config_init_args,                   get_config_init_args,                   clr_config_init_args,                 },
+
+#endif
 };
 
 static const size_t config_jump_table_size = sizeof(config_jump_table) / sizeof(struct lxc_config_t);
@@ -6094,3 +6101,58 @@ int lxc_list_net(struct lxc_conf *c, const char *key, char *retv, int inlen)
 
 	return fulllen;
 }
+
+#ifdef HAVE_ISULAD
+/* isulad: set config for init args */
+static int set_config_init_args(const char *key, const char *value,
+				 struct lxc_conf *lxc_conf, void *data)
+{
+	int ret = 0;
+	char *tmp = NULL;
+	char *new_value = NULL;
+
+	ret = set_config_string_item(&new_value, value);
+	if (ret || !new_value)
+		return ret;
+
+	tmp = realloc(lxc_conf->init_argv, (lxc_conf->init_argc + 1) * sizeof(char *));
+	if (!tmp) {
+		ERROR("Out of memory");
+		free(new_value);
+		return -1;
+	}
+
+	lxc_conf->init_argv = (char **)tmp;
+
+	lxc_conf->init_argv[lxc_conf->init_argc] = new_value;
+	lxc_conf->init_argc++;
+
+	return 0;
+}
+
+/* isulad: get config init args */
+static int get_config_init_args(const char *key, char *retv, int inlen,
+				  struct lxc_conf *c, void *data)
+{
+	int i, len, fulllen = 0;
+	struct lxc_list *it;
+
+	if (!retv)
+		inlen = 0;
+	else
+		memset(retv, 0, inlen);
+
+	for (i = 0; i < c->init_argc; i++) {
+           strprint(retv, inlen, "%s", c->init_argv[i]);
+    }
+
+	return fulllen;
+}
+
+/* isulad: clr config init args*/
+static inline int clr_config_init_args(const char *key, struct lxc_conf *c,
+				   void *data)
+{
+	return lxc_clear_init_args(c);
+}
+#endif
diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 487d838..f4462fd 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -857,6 +857,33 @@ static bool wait_on_daemonized_start(struct lxc_handler *handler, int pid)
 	return true;
 }
 
+#ifdef HAVE_ISULAD
+/* isulad: use init argv as init cmd */
+static char **use_init_args(char **init_argv, size_t init_args)
+{
+	size_t i;
+	int nargs = 0;
+	char **argv;
+
+	if (!init_argv)
+		return NULL;
+
+	do {
+		argv = malloc(sizeof(char *));
+	} while (!argv);
+
+	argv[0] = NULL;
+	for (i = 0; i < init_args; i++)
+		push_arg(&argv, init_argv[i], &nargs);
+
+	if (nargs == 0) {
+		free(argv);
+		return NULL;
+	}
+	return argv;
+}
+#endif
+
 static bool do_lxcapi_start(struct lxc_container *c, int useinit, char * const argv[])
 {
 	int ret;
@@ -914,6 +941,12 @@ static bool do_lxcapi_start(struct lxc_container *c, int useinit, char * const a
 			argv = init_cmd = split_init_cmd(conf->init_cmd);
 	}
 
+#ifdef HAVE_ISULAD
+	if (!argv) {
+		argv = init_cmd = use_init_args(conf->init_argv, conf->init_argc);
+	}
+#endif
+
 	/* ... otherwise use default_args. */
 	if (!argv) {
 		if (useinit) {
-- 
1.8.3.1

